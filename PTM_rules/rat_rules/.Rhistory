#parse.seq("GPPGQKPPGPQGPRGPPGPPGPM")
parse.seq <- function(sequence,cuts="K|R",skip="X", massmin = 800, massmax = 3500,verbose = F,max.missed.cleaves=0, cutbefore = F){
#initialise some variables
peptides <- NA
pepidx <- 1
len <- str_length(sequence)
start <-1
nextpos <- start
num.mc <- 0
tooheavy <- F
badchar <- F
attheend<-F
pos <-1
cut.offset <- 0
#set the cut offset
if(cutbefore){
cut.offset <- 1
if(verbose)message("Cutting before!")
}
#for(pos in 1:len){
while(!attheend){
#get the current amino acid
aa <- str_sub(sequence, pos+cut.offset, pos+cut.offset)
# if we are at a cut point, we can process the peptide, but note that
# we have to keep track of the start position for the *next* peptide
# which can get complicated as we deal with missed cleaves etc.
if (str_detect(aa, cuts) || pos == len) {
#record the position of the next start sequence
nextpos[num.mc + 1] = pos
#won't cut if next aa is proline (P)
nextaa <- str_sub(sequence, pos+cut.offset + 1, pos+cut.offset + 1)
if (nextaa != "P") {
#increment the number of missed cleaves
num.mc <- num.mc + 1
#get the current peptide sequence.
ss <- str_sub(sequence,start,pos)
#if there are any characters that should be skipped
if(str_detect(ss,skip)){
#do nothing
if(verbose)
message(sprintf("  can't use %s",ss))
badchar <- T
}
#if there are no characters that should be skipped
else{
if(verbose)message(sprintf("found sequence %s",ss))
#calculate the masses without PTMs
masses <- ms_iso(ss)
tooheavy <- F
#if the masses are in range
if(masses$mass[1]>massmin && masses$mass[1] < massmax){
#get the number of possible hydroxylations
nhyd <- str_count(ss,"P") + str_count(ss, "K")
#get the number of possible deamidations
nglut <- str_count(ss,"Q") + str_count(ss,"N")
#Go through each hydroxylation / deamidation combination
for(hh in 0:nhyd){
for(dd in 0:nglut){
#calculate the mass for this PTM
masses <- ms_iso(ss,ndeamidations=dd,nhydroxylations=hh)
#create the new entry in the peptide list
newrow <- data.frame(
seq=as.character(ss)
,nhyd=hh
,nglut=dd
#,mass1 = masses$mass[1] + (dd*0.984015)+(hh*16)
,mass1 = masses$mass[1] + 1
,seq_start = start
,seq_end = pos
,missed.cleaves = num.mc -1 # we have to subtract 1 because we've incremented num.mc already
)
#add the row to the list
if(pepidx==1){
peptides <- newrow
}
else{
peptides <- rbind(peptides,newrow)
}
pepidx <- pepidx+1
}
}
}
else{
if(verbose)message(sprintf("  mass %0.2f out of range for sequence %s",masses$mass[1],ss))
if(masses$mass[1] > massmax)
tooheavy <- T
}
}
#if we are at the limit of mass or num.missed.cleaves, move the start pos on
# or if too heavy
# or if there's a bad character
if(tooheavy || badchar || num.mc > max.missed.cleaves){
start <- nextpos[1]+1
tooheavy <- F
badchar <- F
#rewind the position if we've missed a cleave
if(num.mc > 0)
pos <- nextpos[1]#this will be incremented below!
if(verbose)
message(sprintf("nmc = %0.0f, start =%0.0f, pos = %0.0f\ncleave positions are %0.0f %0.0f %0.0f",num.mc,start,pos,nextpos[1],nextpos[2],nextpos[3]))
num.mc <- 0
}
}
}
pos <- pos + 1
if(pos>len)
break
}
#return NA if no peptides found within the mass range
if(pepidx==1){
if(verbose)message("No peptides found, returning NA")
return(NA)
}else{
if(verbose)message(sprintf("%d Peptides found",pepidx-1))
peptides$seq <- as.character(peptides$seq)
return(peptides)
}
return(peptides)
}
ratseq <- "QMSYGYDEKSAGVSVPGPMGPSGPRGLPGPPGAPGPQGFQGPPGEPGEPGASGPMGPRGPPGPPGKNGDDGEAGKPGRPGERGPPGPQGARGLPGTAGLPGMKGHRGFSGLDGAKGDTGPAGPKGEPGSPGENGAPGQMGPRGLPGERGRPGPPGSAGARGNDGAVGAAGPPGPTGPTGPPGFPGAAGAKGEAGPQGARGSEGPQGVRGEPGPPGPAGAAGPAGNPGADGQPGAKGANGAPGIAGAPGFPGARGPSGPQGPSGAPGPKGNSGEPGAPGNKGDTGAKGEPGPAGVQGPPGPAGEEGKRGARGEPGPSGLPGPPGERGGPGSRGFPGADGVAGPKGPAGERGSPGPAGPKGSPGEAGRPGEAGLPGAKGLTGSPGSPGPDGKTGPPGPAGQDGRPGPAGPPGARGQAGVMGFPGPKGTAGEPGKAGERGVPGPPGAVGPAGKDGEAGAQGAPGPAGPAGERGEQGPAGSPGFQGLPGPAGPPGEAGKPGEQGVPGDLGAPGPSGARGERGFPGERGVQGPPGPAGPRGNNGAPGNDGAKGDTGAPGAPGSQGAPGLQGMPGERGAAGLPGPKGDRGDAGPKGADGSPGKDGVRGLTGPIGPPGPAGAPGDKGETGPSGPAGPTGARGAPGDRGEPGPPGPAGFAGPPGADGQPGAKGEPGDTGVKGDAGPPGPAGPAGPPGPIGNVGAPGPKGSRGAAGPPGATGFPGAAGRVGPPGPSGNAGPPGPPGPVGKEGGKGPRGETGPAGRPGEVGPPGPPGPAGEKGSPGADGPAGSPGTPGPQGIAGQRGVVGLPGQRGERGFPGLPGPSGEPGKQGPSGASGERGPPGPMGPPGLAGPPGESGREGSPGAEGSPGRDGAPGAKGDRGETGPAGPPGAPGAPGAPGPVGPAGKNGDRGETGPAGPAGPIGPAGARGPAGPQGPRGDKGETGEQGDRGIKGHRGFSGLQGPPGSPGSPGEQGPSGASGPAGPRGPPGSAGSPGKDGLNGLPGPIGPPGPRGRTGDSGPAGPPGPPGPPGPPGPPSGGYDFSFLPQPPQEKSQDGGRYYRAQYSDKGVSAGPGPMGLMGPRGPPGAVGAPGPQGFQGPAGEPGEPGQTGPAGSRGPAGPPGKAGEDGHPGKPGRPGERGVVGPQGARGFPGTPGLPGFKGIRGHNGLDGLKGQPGAQGVKGEPGAPGENGTPGQAGARGLPGERGRVGAPGPAGARGSDGSVGPVGPAGPIGSAGPPGFPGAPGPKGELGPVGNPGPAGPAGPRGEAGLPGLSGPVGPPGNPGANGLTGAKGATGLPGVAGAPGLPGPRGIPGPVGAAGATGPRGLVGEPGPAGSKGETGNKGEPGSAGAQGPPGPSGEEGKRGSPGEPGSAGPAGPPGLRGSPGSRGLPGADGRAGVMGPPGNRGSTGPAGVRGPNGDAGRPGEPGLMGPRGLPGSPGNVGPAGKEGPVGLPGIDGRPGPIGPAGPRGEAGNIGFPGPKGPSGDPGKPGEKGHPGLAGARGAPGPDGNNGAQGPPGPQGVQGGKGEQGPAGPPGFQGLPGPSGTAGEVGKPGERGLPGEFGLPGPAGPRGERGPPGESGAAGPSGPIGIRGPSGAPGPDGNKGEAGAVGAPGSAGASGPGGLPGERGAAGIPGGKGEKGETGLRGEIGNPGRDGARGAPGAIGAPGPAGASGDRGEAGAAGPSGPAGPRGSPGERGEVGPAGPNGFAGPAGSAGQPGAKGEKGTKGPKGENGIVGPTGPVGAAGPSGPNGPPGPAGSRGDGGPPGMTGFPGAAGRTGPPGPSGITGPPGPPGAAGKEGIRGPRGDQGPVGRTGEIGASGPPGFAGEKGPSGEPGTTGPPGTAGPQGLLGAPGILGLPGSRGERGQPGIAGALGEPGPLGIAGPPGARGPPGAVGSPGVNGAPGEAGRDGNPGSDGPPGRDGQPGHKGERGYPGNIGPTGAAGAPGPHGSVGPAGKHGNRGEPGPAGSVGPVGAVGPRGPSGPQGIRGDKGEPGDKGARGLPGLKGHNGLQGLPGLAGLHGDQGAPGPVGPAGPRGPAGPSGPIGKDGRSGHPGPVGPAGVRGSQGSQGPAGPPGPPGPPGPPGVSGGGYDFGFEGGFYRA"
rat_table_all_1 <- parse.seq(ratseq, max.missed.cleaves = 1)
#rat_table_all <- rat_table_all[order(rat_table_all$mass1, decreasing = FALSE), ]
View(rat_table_all_1)
ratseq <- "QMSYGYDEKSAGVSVPGPMGPSGPRGLPGPPGAPGPQGFQGPPGEPGEPGASGPMGPRGPPGPPGKNGDDGEAGKPGRPGERGPPGPQGARGLPGTAGLPGMKGHRGFSGLDGAKGDTGPAGPKGEPGSPGENGAPGQMGPRGLPGERGRPGPPGSAGARGNDGAVGAAGPPGPTGPTGPPGFPGAAGAKGEAGPQGARGSEGPQGVRGEPGPPGPAGAAGPAGNPGADGQPGAKGANGAPGIAGAPGFPGARGPSGPQGPSGAPGPKGNSGEPGAPGNKGDTGAKGEPGPAGVQGPPGPAGEEGKRGARGEPGPSGLPGPPGERGGPGSRGFPGADGVAGPKGPAGERGSPGPAGPKGSPGEAGRPGEAGLPGAKGLTGSPGSPGPDGKTGPPGPAGQDGRPGPAGPPGARGQAGVMGFPGPKGTAGEPGKAGERGVPGPPGAVGPAGKDGEAGAQGAPGPAGPAGERGEQGPAGSPGFQGLPGPAGPPGEAGKPGEQGVPGDLGAPGPSGARGERGFPGERGVQGPPGPAGPRGNNGAPGNDGAKGDTGAPGAPGSQGAPGLQGMPGERGAAGLPGPKGDRGDAGPKGADGSPGKDGVRGLTGPIGPPGPAGAPGDKGETGPSGPAGPTGARGAPGDRGEPGPPGPAGFAGPPGADGQPGAKGEPGDTGVKGDAGPPGPAGPAGPPGPIGNVGAPGPKGSRGAAGPPGATGFPGAAGRVGPPGPSGNAGPPGPPGPVGKEGGKGPRGETGPAGRPGEVGPPGPPGPAGEKGSPGADGPAGSPGTPGPQGIAGQRGVVGLPGQRGERGFPGLPGPSGEPGKQGPSGASGERGPPGPMGPPGLAGPPGESGREGSPGAEGSPGRDGAPGAKGDRGETGPAGPPGAPGAPGAPGPVGPAGKNGDRGETGPAGPAGPIGPAGARGPAGPQGPRGDKGETGEQGDRGIKGHRGFSGLQGPPGSPGSPGEQGPSGASGPAGPRGPPGSAGSPGKDGLNGLPGPIGPPGPRGRTGDSGPAGPPGPPGPPGPPGPPSGGYDFSFLPQPPQEKSQDGGRYYRAQYSDKGVSAGPGPMGLMGPRGPPGAVGAPGPQGFQGPAGEPGEPGQTGPAGSRGPAGPPGKAGEDGHPGKPGRPGERGVVGPQGARGFPGTPGLPGFKGIRGHNGLDGLKGQPGAQGVKGEPGAPGENGTPGQAGARGLPGERGRVGAPGPAGARGSDGSVGPVGPAGPIGSAGPPGFPGAPGPKGELGPVGNPGPAGPAGPRGEAGLPGLSGPVGPPGNPGANGLTGAKGATGLPGVAGAPGLPGPRGIPGPVGAAGATGPRGLVGEPGPAGSKGETGNKGEPGSAGAQGPPGPSGEEGKRGSPGEPGSAGPAGPPGLRGSPGSRGLPGADGRAGVMGPPGNRGSTGPAGVRGPNGDAGRPGEPGLMGPRGLPGSPGNVGPAGKEGPVGLPGIDGRPGPIGPAGPRGEAGNIGFPGPKGPSGDPGKPGEKGHPGLAGARGAPGPDGNNGAQGPPGPQGVQGGKGEQGPAGPPGFQGLPGPSGTAGEVGKPGERGLPGEFGLPGPAGPRGERGPPGESGAAGPSGPIGIRGPSGAPGPDGNKGEAGAVGAPGSAGASGPGGLPGERGAAGIPGGKGEKGETGLRGEIGNPGRDGARGAPGAIGAPGPAGASGDRGEAGAAGPSGPAGPRGSPGERGEVGPAGPNGFAGPAGSAGQPGAKGEKGTKGPKGENGIVGPTGPVGAAGPSGPNGPPGPAGSRGDGGPPGMTGFPGAAGRTGPPGPSGITGPPGPPGAAGKEGIRGPRGDQGPVGRTGEIGASGPPGFAGEKGPSGEPGTTGPPGTAGPQGLLGAPGILGLPGSRGERGQPGIAGALGEPGPLGIAGPPGARGPPGAVGSPGVNGAPGEAGRDGNPGSDGPPGRDGQPGHKGERGYPGNIGPTGAAGAPGPHGSVGPAGKHGNRGEPGPAGSVGPVGAVGPRGPSGPQGIRGDKGEPGDKGARGLPGLKGHNGLQGLPGLAGLHGDQGAPGPVGPAGPRGPAGPSGPIGKDGRSGHPGPVGPAGVRGSQGSQGPAGPPGPPGPPGPPGVSGGGYDFGFEGGFYRA"
rat_table_all_1 <- parse.seq(ratseq, max.missed.cleaves = 1)
write.csv(rat_table_all_1, file = 'theor_rat.csv')
View(rat_table_all_1)
library("bacollite")
##adding the source for the functions used
source("parseseq.R")
source("mass_iso.R")
source("RcppExports.R")
#' Parse an amino acid sequence into a set of peptides, incorporating hydroxylation and deamidation modifications, and calculating mass
#'
#' @param seqeunce a character string holding the sequence, e.g. "GPPGAPGPPGPP"
#' @param cuts a regular expression listing the amino acids that the sequence should be cut at. Defaults to Trypsing cut sites K & R
#' @param skip any codes that mean the peptide is invalid. Defaults to "X"
#' @param massmin the minimum mass that a peptide should be. Defaults to 800
#' @param massmax the maximum mass that a peptide should be. Defaults to 3500
#' @param verbose whether to print messages to console during processing. Defaults to FALSE
#' @param max.missed.cleaves the number of missed cleaves to incorporate in the set of peptides.
#' @import stringr
#' @export
#' @examples
#parse.seq("GPPGQKPPGPQGPRGPPGPPGPM")
parse.seq <- function(sequence,cuts="K|R",skip="X", massmin = 800, massmax = 3500,verbose = F,max.missed.cleaves=0, cutbefore = F){
#initialise some variables
peptides <- NA
pepidx <- 1
len <- str_length(sequence)
start <-1
nextpos <- start
num.mc <- 0
tooheavy <- F
badchar <- F
attheend<-F
pos <-1
cut.offset <- 0
#set the cut offset
if(cutbefore){
cut.offset <- 1
if(verbose)message("Cutting before!")
}
#for(pos in 1:len){
while(!attheend){
#get the current amino acid
aa <- str_sub(sequence, pos+cut.offset, pos+cut.offset)
# if we are at a cut point, we can process the peptide, but note that
# we have to keep track of the start position for the *next* peptide
# which can get complicated as we deal with missed cleaves etc.
if (str_detect(aa, cuts) || pos == len) {
#record the position of the next start sequence
nextpos[num.mc + 1] = pos
#won't cut if next aa is proline (P)
nextaa <- str_sub(sequence, pos+cut.offset + 1, pos+cut.offset + 1)
if (nextaa != "P") {
#increment the number of missed cleaves
num.mc <- num.mc + 1
#get the current peptide sequence.
ss <- str_sub(sequence,start,pos)
#if there are any characters that should be skipped
if(str_detect(ss,skip)){
#do nothing
if(verbose)
message(sprintf("  can't use %s",ss))
badchar <- T
}
#if there are no characters that should be skipped
else{
if(verbose)message(sprintf("found sequence %s",ss))
#calculate the masses without PTMs
masses <- ms_iso(ss)
tooheavy <- F
#if the masses are in range
if(masses$mass[1]>massmin && masses$mass[1] < massmax){
#get the number of possible hydroxylations
nhyd <- str_count(ss,"P") + str_count(ss, "K")
#get the number of possible deamidations
nglut <- str_count(ss,"Q") + str_count(ss,"N")
#Go through each hydroxylation / deamidation combination
for(hh in 0:nhyd){
for(dd in 0:nglut){
#calculate the mass for this PTM
masses <- ms_iso(ss,ndeamidations=dd,nhydroxylations=hh)
#create the new entry in the peptide list
newrow <- data.frame(
seq=as.character(ss)
,nhyd=hh
,nglut=dd
#,mass1 = masses$mass[1] + (dd*0.984015)+(hh*16)
,mass1 = masses$mass[1] + 1
,seq_start = start
,seq_end = pos
,missed.cleaves = num.mc -1 # we have to subtract 1 because we've incremented num.mc already
,pep_id = pepidx
)
#add the row to the list
if(pepidx==1){
peptides <- newrow
}
else{
peptides <- rbind(peptides,newrow)
}
pepidx <- pepidx+1
}
}
}
else{
if(verbose)message(sprintf("  mass %0.2f out of range for sequence %s",masses$mass[1],ss))
if(masses$mass[1] > massmax)
tooheavy <- T
}
}
#if we are at the limit of mass or num.missed.cleaves, move the start pos on
# or if too heavy
# or if there's a bad character
if(tooheavy || badchar || num.mc > max.missed.cleaves){
start <- nextpos[1]+1
tooheavy <- F
badchar <- F
#rewind the position if we've missed a cleave
if(num.mc > 0)
pos <- nextpos[1]#this will be incremented below!
if(verbose)
message(sprintf("nmc = %0.0f, start =%0.0f, pos = %0.0f\ncleave positions are %0.0f %0.0f %0.0f",num.mc,start,pos,nextpos[1],nextpos[2],nextpos[3]))
num.mc <- 0
}
}
}
pos <- pos + 1
if(pos>len)
break
}
#return NA if no peptides found within the mass range
if(pepidx==1){
if(verbose)message("No peptides found, returning NA")
return(NA)
}else{
if(verbose)message(sprintf("%d Peptides found",pepidx-1))
peptides$seq <- as.character(peptides$seq)
return(peptides)
}
return(peptides)
}
ratseq <- "QMSYGYDEKSAGVSVPGPMGPSGPRGLPGPPGAPGPQGFQGPPGEPGEPGASGPMGPRGPPGPPGKNGDDGEAGKPGRPGERGPPGPQGARGLPGTAGLPGMKGHRGFSGLDGAKGDTGPAGPKGEPGSPGENGAPGQMGPRGLPGERGRPGPPGSAGARGNDGAVGAAGPPGPTGPTGPPGFPGAAGAKGEAGPQGARGSEGPQGVRGEPGPPGPAGAAGPAGNPGADGQPGAKGANGAPGIAGAPGFPGARGPSGPQGPSGAPGPKGNSGEPGAPGNKGDTGAKGEPGPAGVQGPPGPAGEEGKRGARGEPGPSGLPGPPGERGGPGSRGFPGADGVAGPKGPAGERGSPGPAGPKGSPGEAGRPGEAGLPGAKGLTGSPGSPGPDGKTGPPGPAGQDGRPGPAGPPGARGQAGVMGFPGPKGTAGEPGKAGERGVPGPPGAVGPAGKDGEAGAQGAPGPAGPAGERGEQGPAGSPGFQGLPGPAGPPGEAGKPGEQGVPGDLGAPGPSGARGERGFPGERGVQGPPGPAGPRGNNGAPGNDGAKGDTGAPGAPGSQGAPGLQGMPGERGAAGLPGPKGDRGDAGPKGADGSPGKDGVRGLTGPIGPPGPAGAPGDKGETGPSGPAGPTGARGAPGDRGEPGPPGPAGFAGPPGADGQPGAKGEPGDTGVKGDAGPPGPAGPAGPPGPIGNVGAPGPKGSRGAAGPPGATGFPGAAGRVGPPGPSGNAGPPGPPGPVGKEGGKGPRGETGPAGRPGEVGPPGPPGPAGEKGSPGADGPAGSPGTPGPQGIAGQRGVVGLPGQRGERGFPGLPGPSGEPGKQGPSGASGERGPPGPMGPPGLAGPPGESGREGSPGAEGSPGRDGAPGAKGDRGETGPAGPPGAPGAPGAPGPVGPAGKNGDRGETGPAGPAGPIGPAGARGPAGPQGPRGDKGETGEQGDRGIKGHRGFSGLQGPPGSPGSPGEQGPSGASGPAGPRGPPGSAGSPGKDGLNGLPGPIGPPGPRGRTGDSGPAGPPGPPGPPGPPGPPSGGYDFSFLPQPPQEKSQDGGRYYRAQYSDKGVSAGPGPMGLMGPRGPPGAVGAPGPQGFQGPAGEPGEPGQTGPAGSRGPAGPPGKAGEDGHPGKPGRPGERGVVGPQGARGFPGTPGLPGFKGIRGHNGLDGLKGQPGAQGVKGEPGAPGENGTPGQAGARGLPGERGRVGAPGPAGARGSDGSVGPVGPAGPIGSAGPPGFPGAPGPKGELGPVGNPGPAGPAGPRGEAGLPGLSGPVGPPGNPGANGLTGAKGATGLPGVAGAPGLPGPRGIPGPVGAAGATGPRGLVGEPGPAGSKGETGNKGEPGSAGAQGPPGPSGEEGKRGSPGEPGSAGPAGPPGLRGSPGSRGLPGADGRAGVMGPPGNRGSTGPAGVRGPNGDAGRPGEPGLMGPRGLPGSPGNVGPAGKEGPVGLPGIDGRPGPIGPAGPRGEAGNIGFPGPKGPSGDPGKPGEKGHPGLAGARGAPGPDGNNGAQGPPGPQGVQGGKGEQGPAGPPGFQGLPGPSGTAGEVGKPGERGLPGEFGLPGPAGPRGERGPPGESGAAGPSGPIGIRGPSGAPGPDGNKGEAGAVGAPGSAGASGPGGLPGERGAAGIPGGKGEKGETGLRGEIGNPGRDGARGAPGAIGAPGPAGASGDRGEAGAAGPSGPAGPRGSPGERGEVGPAGPNGFAGPAGSAGQPGAKGEKGTKGPKGENGIVGPTGPVGAAGPSGPNGPPGPAGSRGDGGPPGMTGFPGAAGRTGPPGPSGITGPPGPPGAAGKEGIRGPRGDQGPVGRTGEIGASGPPGFAGEKGPSGEPGTTGPPGTAGPQGLLGAPGILGLPGSRGERGQPGIAGALGEPGPLGIAGPPGARGPPGAVGSPGVNGAPGEAGRDGNPGSDGPPGRDGQPGHKGERGYPGNIGPTGAAGAPGPHGSVGPAGKHGNRGEPGPAGSVGPVGAVGPRGPSGPQGIRGDKGEPGDKGARGLPGLKGHNGLQGLPGLAGLHGDQGAPGPVGPAGPRGPAGPSGPIGKDGRSGHPGPVGPAGVRGSQGSQGPAGPPGPPGPPGPPGVSGGGYDFGFEGGFYRA"
rat_table_all_1 <- parse.seq(ratseq, max.missed.cleaves = 1)
write.csv(rat_table_all_1, file = 'theor_rat.csv')
#rat_table_all <- rat_table_all[order(rat_table_all$mass1, decreasing = FALSE), ]
View(rat_table_all_1)
setwd("C:/Users/tobyl/OneDrive - The University of Manchester/Bioinformatics Masters/Research project 1/Git_repositories/RP1_m-z_speciesidentify")
library(dplyr)
sampledf <- read.table("rat_sample2.txt", sep = '\t', col.names = c("m.z", "intensity"))
sampledf <- sampledf %>%
mutate(across(c('m.z'), round, 1))
sampledf$m.z_plus1 <- sampledf$m.z + 0.1
sampledf$m.zminus1 <- sampledf$m.z - 0.1
rat_table_df <- read.csv("results.csv")
rat_table_df <- read.csv("results.csv", sep = ",")
setwd("C:/Users/tobyl/OneDrive - The University of Manchester/Bioinformatics Masters/Research project 1/Git_repositories/RP1_m-z_speciesidentify/PTM_rules/rat_rules")
rat_table_df <- read.csv("results.csv", sep = ",")
View(rat_table_df)
library(dplyr)
sampledf3 <- read.table("rat_sample.txt", sep = '\t', col.names = c("m.z", "intensity"))
sampledf3 <- sampledf3 %>%
mutate(across(c('m.z'), round, 1))
sampledf3$m.z_plus1 <- sampledf3$m.z + 0.1
sampledf3$m.zminus1 <- sampledf3$m.z - 0.1
rat_table_df <- read.csv("results.csv", sep = ",")
rat_table_df <- rat_table_df %>%
mutate(across(c(PMF_predict), round, 1))
library(dplyr)
sampledf3 <- read.table("rat_sample.txt", sep = '\t', col.names = c("m.z", "intensity"))
sampledf3 <- sampledf3 %>%
mutate(across(c('m.z'), round, 1))
sampledf3$m.z_plus1 <- sampledf3$m.z + 0.1
sampledf3$m.zminus1 <- sampledf3$m.z - 0.1
rat_table_df <- read.csv("results.csv", sep = ",")
rat_table_df <- rat_table_df %>%
mutate(across(c(mass1), round, 1))
mass_list = c()
count = 0
for (mass in rat_table_df$mass1) {
for (row in 1:nrow(sampledf3)) {
if (mass <= sampledf3[row, "m.z_plus1"] & mass >= sampledf3[row,"m.zminus1"]) {
mass_list <- append(mass_list, sampledf3[row, "m.z"])
#print(mass)
#print(sampledf[row, "m.z_plus1"])
#print(sampledf[row,"m.zminus1"])
count = count + 1
}
}
}
print(count)
print(length(unique(mass_list)))
rat_table_df <- read.csv("sequence_masses.csv", sep = ",")
View(rat_table_df)
library(dplyr)
sampledf3 <- read.table("rat_sample.txt", sep = '\t', col.names = c("m.z", "intensity"))
sampledf3 <- sampledf3 %>%
mutate(across(c('m.z'), round, 1))
sampledf3$m.z_plus1 <- sampledf3$m.z + 0.1
sampledf3$m.zminus1 <- sampledf3$m.z - 0.1
rat_table_df <- read.csv("sequence_masses.csv", sep = ",")
rat_table_df <- rat_table_df %>%
mutate(across(c(PMF_predict), round, 1))
mass_list = c()
count = 0
for (mass in rat_table_df$PMF_predict) {
for (row in 1:nrow(sampledf3)) {
if (mass <= sampledf3[row, "m.z_plus1"] & mass >= sampledf3[row,"m.zminus1"]) {
mass_list <- append(mass_list, sampledf3[row, "m.z"])
#print(mass)
#print(sampledf[row, "m.z_plus1"])
#print(sampledf[row,"m.zminus1"])
count = count + 1
}
}
}
print(count)
print(length(unique(mass_list)))
View(rat_table_df)
library("bacollite")
##adding the source for the functions used
source("parseseq.R")
setwd("C:/Users/tobyl/OneDrive - The University of Manchester/Bioinformatics Masters/Research project 1/Git_repositories/RP1_m-z_speciesidentify")
library("bacollite")
##adding the source for the functions used
source("parseseq.R")
source("mass_iso.R")
source("RcppExports.R")
#' Parse an amino acid sequence into a set of peptides, incorporating hydroxylation and deamidation modifications, and calculating mass
#'
#' @param seqeunce a character string holding the sequence, e.g. "GPPGAPGPPGPP"
#' @param cuts a regular expression listing the amino acids that the sequence should be cut at. Defaults to Trypsing cut sites K & R
#' @param skip any codes that mean the peptide is invalid. Defaults to "X"
#' @param massmin the minimum mass that a peptide should be. Defaults to 800
#' @param massmax the maximum mass that a peptide should be. Defaults to 3500
#' @param verbose whether to print messages to console during processing. Defaults to FALSE
#' @param max.missed.cleaves the number of missed cleaves to incorporate in the set of peptides.
#' @import stringr
#' @export
#' @examples
#parse.seq("GPPGQKPPGPQGPRGPPGPPGPM")
parse.seq <- function(sequence,cuts="K|R",skip="X", massmin = 800, massmax = 3500,verbose = F,max.missed.cleaves=0, cutbefore = F){
#initialise some variables
peptides <- NA
pepidx <- 1
len <- str_length(sequence)
start <-1
nextpos <- start
num.mc <- 0
tooheavy <- F
badchar <- F
attheend<-F
pos <-1
cut.offset <- 0
#set the cut offset
if(cutbefore){
cut.offset <- 1
if(verbose)message("Cutting before!")
}
#for(pos in 1:len){
while(!attheend){
#get the current amino acid
aa <- str_sub(sequence, pos+cut.offset, pos+cut.offset)
# if we are at a cut point, we can process the peptide, but note that
# we have to keep track of the start position for the *next* peptide
# which can get complicated as we deal with missed cleaves etc.
if (str_detect(aa, cuts) || pos == len) {
#record the position of the next start sequence
nextpos[num.mc + 1] = pos
#won't cut if next aa is proline (P)
nextaa <- str_sub(sequence, pos+cut.offset + 1, pos+cut.offset + 1)
if (nextaa != "P") {
#increment the number of missed cleaves
num.mc <- num.mc + 1
#get the current peptide sequence.
ss <- str_sub(sequence,start,pos)
#if there are any characters that should be skipped
if(str_detect(ss,skip)){
#do nothing
if(verbose)
message(sprintf("  can't use %s",ss))
badchar <- T
}
#if there are no characters that should be skipped
else{
if(verbose)message(sprintf("found sequence %s",ss))
#calculate the masses without PTMs
masses <- ms_iso(ss)
tooheavy <- F
#if the masses are in range
if(masses$mass[1]>massmin && masses$mass[1] < massmax){
#get the number of possible hydroxylations
nhyd <- str_count(ss,"P") + str_count(ss, "K")
#get the number of possible deamidations
nglut <- str_count(ss,"Q") + str_count(ss,"N")
#Go through each hydroxylation / deamidation combination
for(hh in 0:nhyd){
for(dd in 0:nglut){
#calculate the mass for this PTM
masses <- ms_iso(ss,ndeamidations=dd,nhydroxylations=hh)
#create the new entry in the peptide list
newrow <- data.frame(
seq=as.character(ss)
,nhyd=hh
,nglut=dd
#,mass1 = masses$mass[1] + (dd*0.984015)+(hh*16)
,mass1 = masses$mass[1]
,seq_start = start
,seq_end = pos
,missed.cleaves = num.mc -1 # we have to subtract 1 because we've incremented num.mc already
)
#add the row to the list
if(pepidx==1){
peptides <- newrow
}
else{
peptides <- rbind(peptides,newrow)
}
pepidx <- pepidx+1
}
}
}
else{
if(verbose)message(sprintf("  mass %0.2f out of range for sequence %s",masses$mass[1],ss))
if(masses$mass[1] > massmax)
tooheavy <- T
}
}
#if we are at the limit of mass or num.missed.cleaves, move the start pos on
# or if too heavy
# or if there's a bad character
if(tooheavy || badchar || num.mc > max.missed.cleaves){
start <- nextpos[1]+1
tooheavy <- F
badchar <- F
#rewind the position if we've missed a cleave
if(num.mc > 0)
pos <- nextpos[1]#this will be incremented below!
if(verbose)
message(sprintf("nmc = %0.0f, start =%0.0f, pos = %0.0f\ncleave positions are %0.0f %0.0f %0.0f",num.mc,start,pos,nextpos[1],nextpos[2],nextpos[3]))
num.mc <- 0
}
}
}
pos <- pos + 1
if(pos>len)
break
}
#return NA if no peptides found within the mass range
if(pepidx==1){
if(verbose)message("No peptides found, returning NA")
return(NA)
}else{
if(verbose)message(sprintf("%d Peptides found",pepidx-1))
peptides$seq <- as.character(peptides$seq)
return(peptides)
}
return(peptides)
}
ratseq <- "QMSYGYDEKSAGVSVPGPMGPSGPRGLPGPPGAPGPQGFQGPPGEPGEPGASGPMGPRGPPGPPGKNGDDGEAGKPGRPGERGPPGPQGARGLPGTAGLPGMKGHRGFSGLDGAKGDTGPAGPKGEPGSPGENGAPGQMGPRGLPGERGRPGPPGSAGARGNDGAVGAAGPPGPTGPTGPPGFPGAAGAKGEAGPQGARGSEGPQGVRGEPGPPGPAGAAGPAGNPGADGQPGAKGANGAPGIAGAPGFPGARGPSGPQGPSGAPGPKGNSGEPGAPGNKGDTGAKGEPGPAGVQGPPGPAGEEGKRGARGEPGPSGLPGPPGERGGPGSRGFPGADGVAGPKGPAGERGSPGPAGPKGSPGEAGRPGEAGLPGAKGLTGSPGSPGPDGKTGPPGPAGQDGRPGPAGPPGARGQAGVMGFPGPKGTAGEPGKAGERGVPGPPGAVGPAGKDGEAGAQGAPGPAGPAGERGEQGPAGSPGFQGLPGPAGPPGEAGKPGEQGVPGDLGAPGPSGARGERGFPGERGVQGPPGPAGPRGNNGAPGNDGAKGDTGAPGAPGSQGAPGLQGMPGERGAAGLPGPKGDRGDAGPKGADGSPGKDGVRGLTGPIGPPGPAGAPGDKGETGPSGPAGPTGARGAPGDRGEPGPPGPAGFAGPPGADGQPGAKGEPGDTGVKGDAGPPGPAGPAGPPGPIGNVGAPGPKGSRGAAGPPGATGFPGAAGRVGPPGPSGNAGPPGPPGPVGKEGGKGPRGETGPAGRPGEVGPPGPPGPAGEKGSPGADGPAGSPGTPGPQGIAGQRGVVGLPGQRGERGFPGLPGPSGEPGKQGPSGASGERGPPGPMGPPGLAGPPGESGREGSPGAEGSPGRDGAPGAKGDRGETGPAGPPGAPGAPGAPGPVGPAGKNGDRGETGPAGPAGPIGPAGARGPAGPQGPRGDKGETGEQGDRGIKGHRGFSGLQGPPGSPGSPGEQGPSGASGPAGPRGPPGSAGSPGKDGLNGLPGPIGPPGPRGRTGDSGPAGPPGPPGPPGPPGPPSGGYDFSFLPQPPQEKSQDGGRYYRAQYSDKGVSAGPGPMGLMGPRGPPGAVGAPGPQGFQGPAGEPGEPGQTGPAGSRGPAGPPGKAGEDGHPGKPGRPGERGVVGPQGARGFPGTPGLPGFKGIRGHNGLDGLKGQPGAQGVKGEPGAPGENGTPGQAGARGLPGERGRVGAPGPAGARGSDGSVGPVGPAGPIGSAGPPGFPGAPGPKGELGPVGNPGPAGPAGPRGEAGLPGLSGPVGPPGNPGANGLTGAKGATGLPGVAGAPGLPGPRGIPGPVGAAGATGPRGLVGEPGPAGSKGETGNKGEPGSAGAQGPPGPSGEEGKRGSPGEPGSAGPAGPPGLRGSPGSRGLPGADGRAGVMGPPGNRGSTGPAGVRGPNGDAGRPGEPGLMGPRGLPGSPGNVGPAGKEGPVGLPGIDGRPGPIGPAGPRGEAGNIGFPGPKGPSGDPGKPGEKGHPGLAGARGAPGPDGNNGAQGPPGPQGVQGGKGEQGPAGPPGFQGLPGPSGTAGEVGKPGERGLPGEFGLPGPAGPRGERGPPGESGAAGPSGPIGIRGPSGAPGPDGNKGEAGAVGAPGSAGASGPGGLPGERGAAGIPGGKGEKGETGLRGEIGNPGRDGARGAPGAIGAPGPAGASGDRGEAGAAGPSGPAGPRGSPGERGEVGPAGPNGFAGPAGSAGQPGAKGEKGTKGPKGENGIVGPTGPVGAAGPSGPNGPPGPAGSRGDGGPPGMTGFPGAAGRTGPPGPSGITGPPGPPGAAGKEGIRGPRGDQGPVGRTGEIGASGPPGFAGEKGPSGEPGTTGPPGTAGPQGLLGAPGILGLPGSRGERGQPGIAGALGEPGPLGIAGPPGARGPPGAVGSPGVNGAPGEAGRDGNPGSDGPPGRDGQPGHKGERGYPGNIGPTGAAGAPGPHGSVGPAGKHGNRGEPGPAGSVGPVGAVGPRGPSGPQGIRGDKGEPGDKGARGLPGLKGHNGLQGLPGLAGLHGDQGAPGPVGPAGPRGPAGPSGPIGKDGRSGHPGPVGPAGVRGSQGSQGPAGPPGPPGPPGPPGVSGGGYDFGFEGGFYRA"
rat_table_all_1 <- parse.seq(ratseq, max.missed.cleaves = 1)
write.csv(rat_table_all_1, file = 'theor_rat.csv')
#rat_table_all <- rat_table_all[order(rat_table_all$mass1, decreasing = FALSE), ]
View(rat_table_all_1)
setwd("C:/Users/tobyl/OneDrive - The University of Manchester/Bioinformatics Masters/Research project 1/Git_repositories/RP1_m-z_speciesidentify/PTM_rules/rat_rules")
rat_table_df <- read.csv("results.csv", sep = ",")
library(dplyr)
sampledf3 <- read.table("rat_sample.txt", sep = '\t', col.names = c("m.z", "intensity"))
sampledf3 <- sampledf3 %>%
mutate(across(c('m.z'), round, 1))
sampledf3$m.z_plus1 <- sampledf3$m.z + 0.1
sampledf3$m.zminus1 <- sampledf3$m.z - 0.1
rat_table_df <- read.csv("results.csv", sep = ",")
rat_table_df <- rat_table_df %>%
mutate(across(c(mass1), round, 1))
mass_list = c()
count = 0
for (mass in rat_table_df$mass1) {
for (row in 1:nrow(sampledf3)) {
if (mass <= sampledf3[row, "m.z_plus1"] & mass >= sampledf3[row,"m.zminus1"]) {
mass_list <- append(mass_list, sampledf3[row, "m.z"])
#print(mass)
#print(sampledf[row, "m.z_plus1"])
#print(sampledf[row,"m.zminus1"])
count = count + 1
}
}
}
print(count)
print(length(unique(mass_list)))
